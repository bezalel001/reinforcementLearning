# N3_contextual Solution Overview

## Task 3.1 – ContextualClusteredBandit Wrapper
- Implemented `ContextualClusteredBandit.select` to validate the incoming `State`, infer the user’s cluster via `_fast_predict(s.context)`, cache the cluster in `_last_cluster`, and delegate action selection to the per-cluster base agent.
- Implemented `ContextualClusteredBandit.update` to guard types, reuse `_last_cluster` if no context is provided, and route the reward signal to the same cluster-specific agent so that independent learners evolve per user segment.
- The wrapper was patched onto the class and verified through `tests/test_contextual.py` to ensure selections and updates hit the correct sub-agents.

## Task 3.2 – Selecting the Number of Clusters
- Sampled 10 000 contexts from `RecsysEnvironment`, evaluated `K` from 2 to 10 with scikit-learn’s `KMeans`, and used the Silhouette Score to judge each clustering (`cluster_scores`).
- The best-scoring `K` is stored in `N_CLUSTERS = K_RANGE[np.argmax(cluster_scores)]`, giving the number of states passed to the contextual agent. The accompanying plot visualizes Silhouette vs. cluster count to justify the choice.

## Task 3.3 – Contextual vs. Non-contextual UCB
- Ran a ~20-minute simulation (`SEEDS = np.arange(200)`, `N_STEPS ≈ 600`) comparing standard `UCBAgent(c=1.5)` against the contextualized version that spawns `n_clusters = N_CLUSTERS` independent UCB agents via the wrapper.
- `plot_reward_band` shows the contextual agent consistently outperforms the plain UCB baseline once the clusters are well calibrated, leading to the final answer `CONTEXTUAL_IS_BETTER = True` for the long-run comparison question.

These steps fully solve the notebook: the wrapper routes selections/updates correctly, the clustering hyperparameter is data-driven, and the empirical comparison demonstrates the benefit of contextualization.
